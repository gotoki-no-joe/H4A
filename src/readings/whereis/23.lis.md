---
order: -23000
description: "Longest Increasing Subsequence, LIS"
---

# 23.最長増加部分列（要書き直し）

[最長増加部分列](https://tjkendev.github.io/procon-library/python/dp/lis.html)

長さ $N$ の数列 $[a_1, a_2, \dots, a_N]$ に対して、
$a_{i_1} < a_{i_2} < \dots < a_{i_k}$ となる $i_1 < i_2 < \dots < i_k$ の中で
最大の $k$ や、添え字列 $[i_j]$ や部分列 $[a_{i_j}]$ を求める

つまり、飛び飛びにより大きい要素を拾って作れる最も長い部分列を作れということ。

数列を前からスキャンして、そこまでの数列に関する増加部分列の末尾要素の候補を一つ持ってくるたびに、それを連結することで数列の長さと最後尾の要素がいくつになるかを追跡する。



<hr/>

Haskellの都合で、後ろから考える。つまりロジックを逆にする。

$a_{i+1}$ から $a_N$ までの数列の増加部分列に、長さ $k$ 先頭の値 $x$ のものがあるとする。  
次に調べる値 $a_i$ に関して、 $x < a_i$ ならばこの列の前に $a_i$ を繋げたものは増加列ではないのでお呼びでない。  
一方 $a_i < x$ ならば、この列の前に $a_i$ を繋げると、長さ $k+1$ で先頭の値 $a_i$ の増加部分列になる。  
また、長さ0の部分列に $a_i$ を繋げて長さ $1$ 先頭の値 $a_i$ という増加部分列は常に作れる。  
これを列の先頭に届くまで繰り返すことで、全ての増加部分列を見つけ出すことができる。

```haskell
import Data.List
import Data.Function

increasing_subsequences :: Ord a => [a] -> [[a]]
increasing_subsequences = foldr step [ [] ]
  where
    step a iss = [a] :
                 [a:is | is <- iss, less a is] ++
                 iss

less _ [] = True
less x (y:_) = x < y

longuest_increasing_subsequence :: Ord a => [a] -> [a]
longuest_increasing_subsequence =
  maximumBy (compare `on` length) . increasing_subsequence
```

「最長のもの」だけを見つけることが目的なら、全ての候補を保持している必要はない。
それぞれの長さごとに、その長さの部分列の中で、最大の先頭要素を持つものが、以降の成長が最も期待できる。
そこで、長さごとに、最大の先頭要素だけを追跡する。

末尾から要素 $a_{i+1}$ まで調べて、
長さ $k$ の最大の先頭要素が $x_k$ 、長さ $k+1$ の最大の先頭要素が $x_{k+1}$ であるとき、
$a_i < x_k$ ならば長さ $k+1$ の部分列が作れるが、
$a_i \leq x_{k+1}$ ならば既存のものの方が有利なので差し替えをしない。
長さ $k+1$ の列がまだないときは初めての候補として追加する。

```haskell
import qualified Data.IntMap as IM

longuest_increasing_subsequence :: Ord a => [a] -> (Int,[a]) -- (長さ,lis)
longuest_increasing_subsequence as = IM.findMax m
  where
    m = foldr step (IM.singleton 0 []) as
    step a m = IM.unionWith max m $
               IM.mapKeys succ $ IM.map (a :) $ IM.filter (less a) m

less _ [] = True
less x (y:_) = x < y
```

列そのものは不要なら、先頭の値だけを管理する。

```haskell
import qualified Data.IntMap as IM

longuest_increasing_subsequence :: (Ord a, Bounded a) => [a] -> Int -- 長さ
longuest_increasing_subsequence = fst . IM.findMax . foldr step (IM.singleton 0 maxBound)
  where
    step a m = IM.unionWith max m $
               IM.mapKeys succ $ IM.map (const a) $ IM.filter (a <) m
```

これではまだ考察がふたつ足らなかった。

まず、mの要素は新たなaにより既存のものより1長くなるか、あるいは既にある長さのものが更新されるだけなので、不連続になることはない。つまり写像でなく配列で管理しても無駄は起きないこと。

もうひとつ、mは真に単調減少すること。

ある長さ $k-1$ の列の先頭 $x_{k-1}$ が次の文字 $a_i$ より大きいときのみ、延長の候補となる。 $a_i < x_{k-1}$  
これは長さ $k$ の列の新たな候補であるが、採用されるのは、
現状の長さ $k$ の列の先頭 $x_k$ が $a_i$ より小さいときのみ。 $x_k < a_i$  
つまり合わせると、長さ $k$ の先頭の値が更新されるのは、 $x_{k-1} > a_i > x_k$ のところだけである。  
そして $x'_k = a_i$ と更新されたとき、やはり $x_{k-1} > x'_k = a_i$ である。  
すなわち、更新の操作は m が単調減少であるという性質を保存する。

初期状態である $\{ 0 \mapsto \infty \}$ は単調減少列である。

よって、m は常に単調減少列である。

そして上の考察から、候補列の更新は毎回、 $a_i$ をまたぐたかだか1箇所でしか発生しないことがわかる。
そのような箇所を見つけるには二分探索を用いて $O(\log n)$ で行う。

```haskell
import Data.Array

longuest_increasing_subsequence :: (Ord a, Bounded a) => [a] -> (Int,[a]) -- (長さ,lis)
longuest_increasing_subsequence as = (len, arrN ! len)
  where
    n = length as
    arr0 = listArray (0, n) $ [] : replicate n []
    (len, arrN) = foldr step (0, arr0) as
    step ai larr@(l,arr)
      | gt ai (head $ arr ! k1) = (max l k1, arr // [(k1, ai : (arr ! k))])
      | otherwise = larr
      where
        (_,k) = binarySearch ((ai <) . head . (arr !)) (succ l) 0
        k1 = succ k
    gt _ [] = True
    gt x (y:_) = x > y
```

foldrで持ちまわす状態の右 `arr` は長さごとに最長共有部分列の最もよい候補を持つ配列で、
左 `l` は現在見つかっている最長のそれ、すなわち配列の使用済みの最大の添え字である。

二分検索で $x_k > a_i$ となる添え字 $k$ を探すとき、
仮想的に常に先頭が $a_i$ より大きい添え字0と、
常に先頭は $a_i$ より小さい添え字 `l+1` については対象とならないので、
`less` の定義は不要となった。

次にその添え字 $k$ が $a_i > x_{k+1}$ であるか確認する際に、
$k+1$ が未使用のときこの条件が成立するように `gt` を定義した。




<hr/>

部分列そのものをきれいに求めるためにfoldrを上では用いたのをあきらめ、前からリストをスキャンして最長増加部分列の長さだけを求めるようにした最終版を示す。

```haskell
import qualified Data.IntMap as IM

longuest_increasing_subsequence :: Ord a => [a] -> Int -- 長さ
longuest_increasing_subsequence [] = 0
longuest_increasing_subsequence (a:as) = fst $ IM.findMax m
  where
    m = foldl' step (IM.singleton 1 a) as
    step m a = IM.insertWith min u a m
      where
        u = succ $ binsearch (\i -> a < m IM.! i) 0 $
            succ $ fst $ IM.findMax m
```

binsearchは[二分探索](22.-er-fen-tan-suo-3.md)の関数。\
insertWith min だと、更新しないでよい場合にも同じ値への更新を行いそうな懸念がある。\
stepのwhere節は二分探索でmの中で xl < a < xu となる位置uを探している。

### 関連問題

ABC006D [ACコード](https://atcoder.jp/contests/abc006/submissions/22987707)
\
ABC134 E Sequence Decomposing - 【ACコード】
\
(expert!) AGC024 B Backfront - 【ACコード】
